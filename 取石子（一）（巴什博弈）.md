例题：取石子



描述
​    一天，TT在寝室闲着无聊，和同寝的人玩起了取石子游戏，而由于条件有限，他/她们是用旺仔小馒头当作石子。游戏的规则是这样的。设有一堆石子，数量为N（1<=N<=1000000），两个人轮番取出其中的若干个，每次最多取M个（1<=M<=1000000），最先把石子取完者胜利。我们知道，TT和他/她的室友都十分的聪明，那么如果是TT先取，他/她会取得游戏的胜利么？

    输入
        第一行是一个正整数n表示有n组测试数据
        输入有不到1000组数据，每组数据一行，有两个数N和M,之间用空格分隔。
    输出
        对于每组数据，输出一行。如果先取的TT可以赢得游戏，则输出“Win”，否则输出“Lose”（引号不用输出）
    样例输入
    
        2
        1000 1
        1 100
    
    样例输出
    
        Lose
        Win
---------------------
```c
//C语言版
#include<stdio.h>
int main()
{
	int n,m,t;
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d%d",&n,&m);
		if(n%(m+1)!=0)
		printf("Win\n");
		else
		printf("Lose\n");
	}
	return 0;
}

```

```python
#Pyhton版
a = int(input())
i = 0
while i <= a:
    x, y = input().split(" ")
    x = int(x)
    y = int(y)
    if (x % (y + 1)) != 0:
        print("Win")
    else:
        print("Lose")
    i = i + 1

```

**原理**：**巴什博弈**

***巴什博弈:只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个。最后取光者得胜。***

***显然，如果n=m+1，那么由于一次最多只能取m个，所以，无论先取者拿走多少个，后取者都能够一次拿走剩余的物品，后者取胜。因此我们发现了如何取胜的法则:如果n=(m+1)r+s，(r为任意自然数，s≤m),那么先取者要拿走s个物品，如果后取者拿走k(≤m)个，那么先取者再拿走m+1-k个，结果剩下(m+1)(r-1)个，以后保持这样的取法，那么先取者肯定获胜。总之，要保持给对手留下(m+1)的倍数，就能最后获胜。***

***这个游戏还可以有一种变相的玩法:两个人轮流报数，每次至少报一个，最多报十个，谁能报到100者胜。***

***对于巴什博弈，那么我们规定，如果最后取光者输，那么又会如何呢?***

***(n-1)%(m+1)==0则后手胜利***

***先手会重新决定策略，所以不是简单的相反行的***

***例如n=15，m=3***

***后手 先手 剩余***

***0 2 13***

***1 3 9***

***2 2 5***

***3 1 1***

***1 0 0***

***先手胜利 输的人最后必定只抓走一个，如果>1个，则必定会留一个给对手******





